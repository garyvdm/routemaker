#!/home/garyvdm/dev/cycleroutemaker/ve/bin/python

import argparse
import logging
import functools
import os
import json
import itertools
import sys
import pprint
import msgpack
import signal
import yaml
import copy
from pprint import pprint
import math

import requests
import gpolyline
import geographiclib.geodesic
from gpxpy.gpx import GPX, GPXTrack, GPXTrackPoint, GPXTrackSegment, GPXWaypoint
import html2text

h = html2text.HTML2Text()
h.ignore_emphasis = True
html2text = h.handle


geodesic = geographiclib.geodesic.Geodesic.WGS84

class DelayedKeyboardInterrupt(object):
    def __enter__(self):
        self.signal_received = False
        self.old_handler = signal.getsignal(signal.SIGINT)
        signal.signal(signal.SIGINT, self.handler)

    def handler(self, signal, frame):
        self.signal_received = (signal, frame)
        logging.debug('SIGINT received. Delaying KeyboardInterrupt.')

    def __exit__(self, type, value, traceback):
        signal.signal(signal.SIGINT, self.old_handler)
        if self.signal_received:
            self.old_handler(*self.signal_received)

def multi_cache(cache, get_values, keys, *args, **kargs):
    def get_exist_value_key(key):
        try:
            return True, cache[key], key
        except KeyError:
            return False, None, key
    exists, values, keys = zip(*(get_exist_value_key(key) for key in keys))
    index_and_key_to_get = tuple(
        ((i, key)
        for i, (key, exist) in enumerate(zip(keys, exists))
        if not exist)
    )
    logging.info("Getting {} items".format(len(index_and_key_to_get)))
    values = list(values)
    if index_and_key_to_get:
        keys_to_get = [key for i, key in index_and_key_to_get]
        gotten_values = get_values(keys_to_get, *args, **kargs)
        for (i, key), value in zip(index_and_key_to_get, gotten_values):
            values[i] = value
            cache[key] = value
    return values

def get_equal_spaced_points(points, dist_between_points, start_dist):
    cum_dist = start_dist
    yield (points[0][0], points[0][1], cum_dist )
    dist_from_last_step = 0
    last_point = points[0]
    for point in points[1:]:
        gd = geodesic.Inverse(last_point[0], last_point[1], point[0], point[1])
        line = geodesic.Line(gd['lat1'], gd['lon1'], gd['azi1'])
        point_dist_remaining = gd['s12'] + dist_from_last_step
        while point_dist_remaining > dist_between_points:
            point_dist_remaining -= dist_between_points
            cum_dist += dist_between_points
            new_point = line.Position(gd['s12'] - point_dist_remaining)
            yield (round(new_point['lat2'], 7), round(new_point['lon2'], 7), cum_dist)
        dist_from_last_step = point_dist_remaining
        last_point = point
    cum_dist += dist_from_last_step
    yield (points[-1][0], points[-1][1], cum_dist)
    
def get_spaced_points_with_original_points(points, dist_between_points, start_dist):
    cum_dist = start_dist
    for point0, point1 in zip(points[:-1], points[1:]):
        gd = geodesic.Inverse(point0[0], point0[1], point1[0], point1[1])
        line = geodesic.Line(gd['lat1'], gd['lon1'], gd['azi1'])
        num_points_for_sec = round(gd['s12'] / dist_between_points)
        for i in range(num_points_for_sec):
            dist_from_point0 = gd['s12'] / num_points_for_sec * i
            pos = line.Position(dist_from_point0)
            #print((cum_dist, dist_from_point0, i, gd['s12'], ))
            yield (round(pos['lat2'], 7), round(pos['lon2'], 7), cum_dist + dist_from_point0)
        cum_dist += gd['s12']
    yield (points[-1][0], points[-1][1], cum_dist)
    


def format_dist_to_next(dist):
    if dist == 0:
        return ''
    elif dist < 1000:
        return '{:0} m'.format(round(dist, -1))
    else:
        return '{:0.1f} km'.format(dist/1000)    


parser = argparse.ArgumentParser()
parser.add_argument('route_file', action='store')
parser.add_argument('--debug', action='store_true', help='Output DEBUG messages.')

args = parser.parse_args()

logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO)
logging.getLogger('requests').level = logging.DEBUG if args.debug else logging.ERROR



cache_names = ('elevation_cache', 'route_cache')
caches = [(os.path.join(os.path.dirname(__file__), '{}.pack'.format(name)), name)
          for name in cache_names]

for path, name in caches:
    try:
        with open(path, 'rb') as f:
            locals()[name] = msgpack.unpack(f, use_list=False, encoding='utf8')
    except Exception:
        logging.exception("Could not load {}:".format(name))
        locals()[name] = {}
        

try:
    
    name, ext = os.path.splitext(args.route_file)
    if ext == '.json':
        with open(args.route_file, 'r') as f:
            source = json.load(f)
    else:
        with open(args.route_file, 'r') as f:
            source = yaml.safe_load(f)
    
    session = requests.Session()
    
    join_routes = source.get('join_routes', False)
    output = {
        'title': source['title'],
        'join_routes': join_routes,
        'notes': source.get('notes', True)
    }
    output_routes = output.setdefault('routes', [])
    
    route_file_name, _ = os.path.splitext(args.route_file)
    
    dist_cum = 0

    
    for source_route in source['routes']:
        try:
            if not join_routes:
                dist_cum = 0
            
            logging.info('Processing "{}"'.format(source_route['title']))
            output_route = {
                'title': source_route['title'],
                'color': source_route['color'],
                'side': bool(source_route.get('side', False)),
            }
            
            parts = []
            last_part_destination = None
            logging.info('Fetching Route.')
            
            for part_i, part in enumerate(source_route['parts']):
                use_prev_origin = part.get('use_prev_origin', True)
                part['origin'] = last_part_destination if last_part_destination and use_prev_origin else part['origin']
                route_request = {
                    'origin': part['origin'],
                    'destination': part['destination'],
                    'waypoints': '|'.join(['via:{}'.format(wp) for wp in part['waypoints']]),
                    'avoid': part.get('avoid', 'highways'),
                }
                if part.get('mode'):
                    route_request['mode'] = part.get('mode')
                route_key = tuple(((key, value) for key, value in sorted(route_request.items())))
                if route_key not in route_cache:
                    route_request.update({
                        'sensor': 'false',
                        'key': '***REMOVED***',
                    })
                    last_part_destination = route_request['destination']
                    part_result = session.get('https://maps.googleapis.com/maps/api/directions/json', params=route_request).json()
                    if part_result['status'] != 'OK':
                        raise Exception("{}: {}". format(part_result['status'], route_request))
                    route_cache[route_key] = part_result['routes'][0]
                parts.append(copy.deepcopy(route_cache[route_key]))
        
            output_route['bounds'] = {
                'northeast': {'lat': max([part['bounds']['northeast']['lat'] for part in parts]),
                              'lng': max([part['bounds']['northeast']['lng'] for part in parts]),},
                'southwest': {'lat': min([part['bounds']['southwest']['lat'] for part in parts]),
                              'lng': min([part['bounds']['southwest']['lng'] for part in parts]),},
            }
        
            original_points = []
            points = []
            
            part_point_shifts = []
            
            for part_i, (source_part, part) in enumerate(zip(source_route['parts'], parts)):
                if len(part['legs']) > 1:
                    raise Exception('More than 1 leg.')
                leg = part['legs'][0]
                
                point_shifts = {}
                part_point_shifts.append(point_shifts)
                
                source_part['origin_points'] = [tuple(point) for point in source_part.get('origin_meta', {}).get('points', [])]
                if not source_part['origin_points']:
                    source_part['origin_points']= [tuple((float(s) for s in source_part['origin'].split(',')))]


                source_part['destination_points'] = [tuple(point) for point in source_part.get('destination_meta', {}).get('points', [])]
                if not source_part['destination_points']:
                    source_part['destination_points'] = [tuple((float(s) for s in source_part['destination'].split(',')))]

                part_points = (
                    source_part['origin_points'] + 
                    list(itertools.chain(*(
                        gpolyline.decode(step['polyline']['points'])
                        for step in leg['steps']
                    ))) +
                    source_part['destination_points']
                )
                part_points = [point for point, last_point in zip(part_points, [None] + part_points[:-1]) if point != last_point]
                # points.extend(part_points)
                
                points.append(part_points[0])
                for point_a, point, point_b in zip(part_points[:-2], part_points[1:-1], part_points[2:]):
                    gd_a = geodesic.Inverse(point[0], point[1], point_a[0], point_a[1])
                    gd_b = geodesic.Inverse(point[0], point[1], point_b[0], point_b[1])
                    diff = gd_b['azi1'] - gd_a['azi1']
                    if diff < 0:
                        diff += 360
                    new_point = geodesic.Line(point[0], point[1], diff / 2 + gd_a['azi1']).Position(3 / math.sin(math.radians(diff/2)))
                    new_point_t = (round(new_point['lat2'], 7), round(new_point['lon2'], 7))
                    points.append(new_point_t)
                    point_shifts[point] = new_point_t
                
                points.append(part_points[-1])

            elevations_get_points = list(get_spaced_points_with_original_points(points, 20, dist_cum))

            def part_steps(part_i, source_part, part):
                leg = part['legs'][0]
                origin_meta = source_part.get(
                    'origin_meta', 
                    #{'notes': 'Start at <b>Northcliff Country Club</b>'} if part_i == 0 else None
                    None
                )
                if origin_meta:
                    origin_meta.update({
                        'html_instructions': origin_meta['notes'],
                        'distance': {'value': 0},
                        'points': source_part['origin_points'],
                        'allow_mod': False,
                    })
                    yield origin_meta

                destination_meta = source_part.get(
                    'destination_meta',
                    {'notes': 'Finish at <b>Northcliff Country Club</b>', 'icon': 'finish.png'} if part_i == len(parts) - 1 else None
                )
                
                
                for i, step in enumerate(leg['steps']):
                    #step['points'] = [(step['start_location']['lat'], step['start_location']['lng'])] + gpolyline.decode(step['polyline']['points'])
                    step['points'] = gpolyline.decode(step['polyline']['points'])
                    if i + 1 == len(leg['steps']):
                        step['points'] += source_part['destination_points'][:-1]
                    yield step

                if destination_meta:
                    destination_meta.update({
                        'html_instructions': destination_meta['notes'],
                        'distance': {'value': 0},
                        'points': source_part['destination_points'][-1:],
                        'allow_mod': False,
                    })
                    yield destination_meta
        
            
            last_output_step = None
            
            
            step_mods = {(step_mod['location'][0], step_mod['location'][1], step_mod['maneuver'], ): step_mod
                         for step_mod in source_route.get('step_mods', ())}
            
            output_steps = []
            
            for part_i, (source_part, part, point_shifts) in enumerate(zip(source_route['parts'], parts, part_point_shifts)):
                for step in part_steps(part_i, source_part, part):
                    output_step = {
                        'location': point_shifts.get(step['points'][0], step['points'][0]),
                        'html_instructions': step['html_instructions'],
                    }
                    
                    for key in ('icon', 'marker', 'class'):
                        if key in step and step[key]:
                            output_step[key] = step[key]
                    output_step['maneuver'] = step.get('maneuver', '')
                    
                    output_step['dist_to_next_val'] = step['distance']['value']
                    
                    show_step = True
                    if step['html_instructions'].startswith('Continue'):
                        show_step = False
                    
                    adds = ()
                    
                    if step.get('allow_mod', True):
                        step_mod = step_mods.get((output_step['location'][0], output_step['location'][1], step.get('maneuver', ''), ))
                        if step_mod:
                            if 'show_step' in step_mod:
                                show_step = step_mod['show_step']
                            
                            if 'html_instructions' in step_mod:
                                output_step['html_instructions'] = step_mod['html_instructions']
                            if 'new_maneuver' in step_mod:
                                output_step['maneuver'] = step_mod['new_maneuver']
                            
                            adds = step_mod.get('add', ())
                    
                    if show_step:
                        output_steps.append(output_step)
                        last_output_step = output_step
                    else:
                        last_output_step['dist_to_next_val'] += output_step['dist_to_next_val']
                    
                    for add in adds:
                        last_output_step['dist_to_next_val'] -= add['dist_to_next_val']
                        output_steps.append(add)
            
            for output_step in output_steps:
                output_step['distance'] = '{:0.1f} km'.format(dist_cum/1000)
                dist_cum += output_step['dist_to_next_val']
                output_step['dist_to_next'] = format_dist_to_next(output_step['dist_to_next_val'])
                del output_step['dist_to_next_val']
                
    
            output_route['steps'] = output_steps
            output_route['distance'] = '{:0.1f} km'.format(dist_cum/1000)
            
            output_route['polyline'] = gpolyline.encode_coords(points)
            
            output_route['elevation_gain'] = ''
            output_route['elevation'] = []
            
            logging.info('Fetching Elevation.')
            
            def get_elevation_for_points(points):
                n = 200
                for i in range(0, len(points), n):
                    section_points = points[i:i+n]
                    polyline = gpolyline.encode_coords([(point[0], point[1]) for point in section_points])
                    
                    r = session.get(
                        'https://maps.googleapis.com/maps/api/elevation/json',
                        params={
                            'sensor': 'false',
                            'key': '***REMOVED***',
                            'locations':  "enc:{}".format(polyline)
                        })
                    try:
                        elevations = r.json()
                    except:
                        logging.exception('Error getting elevation json: {}'.format(r.text))
                    if elevations['status'] != 'OK':
                        logging.error(elevations['status'])
                    else:
                        yield from (elv['elevation'] for elv in elevations['results'])
            
            elevations_values = multi_cache(elevation_cache, get_elevation_for_points,
                                            ((point[0], point[1]) for point in elevations_get_points))
            elevations_points = [(point[0], point[1], point[2], value) for point, value in zip(elevations_get_points, elevations_values)]
            
            # elevation_dist = 0
            # 
            # for point0, point1 in zip(elevations_points[:-1], elevations_points[1:]):
            #     dist_diff = point1[2] - point0[2]
            #     elevation_diff = point1[3] - point0[3]
            #     elevation_dist += math.sqrt(dist_diff * dist_diff + elevation_diff * elevation_diff)
            # print((elevation_dist, elevations_points[-1][2]))

            
            elevation_gain = 0
            last_elevations_point = elevations_points[0]
            for elevations_point in elevations_points[1:]:
                if last_elevations_point[3] < elevations_point[3]:
                    elevation_gain += elevations_point[3] - last_elevations_point[3]
                last_elevations_point = elevations_point
            output_route['elevation_gain'] = '{:0.0f} m'.format(elevation_gain)
            
            output_route['elevation'] = elevations_points[0::20]
            
            output['routes'].append(output_route)
    
            gpx = GPX()
            # Create first track in our GPX:
            gpx_track = GPXTrack(name=source['title'] + ' - ' + source_route['title'])
            gpx.tracks.append(gpx_track)
            
            # Create first segment in our GPX track:
            gpx_segment = GPXTrackSegment()
            gpx_track.segments.append(gpx_segment)
            
            for point in points:
                gpx_segment.points.append(GPXTrackPoint(point[0], point[1]))
                
            for step in output_steps:
                location = step['location']
                gpx.waypoints.append(GPXWaypoint(location[0], location[1], description=html2text(step['html_instructions'])))
            
            with open(source['title'] + ' - ' + source_route['title'] + '.gpx', 'w') as f:
                f.write(gpx.to_xml())
            
        except Exception:
            logging.exception('Error processing route {}'.format(source_route['title']))
    
    output['bounds'] = {
        'northeast': {'lat': max([route['bounds']['northeast']['lat'] for route in output_routes]),
                      'lng': max([route['bounds']['northeast']['lng'] for route in output_routes]),},
        'southwest': {'lat': min([route['bounds']['southwest']['lat'] for route in output_routes]),
                      'lng': min([route['bounds']['southwest']['lng'] for route in output_routes]),},
    }
    
    with open(route_file_name + '_web.json', 'w') as f:
        json.dump(output, f, sort_keys=True)

    with open(route_file_name + '_web.yaml', 'w') as f:
        yaml.safe_dump(output, f)


finally:
    with DelayedKeyboardInterrupt():
        for path, name in caches:
            with open(path, 'wb') as f:
                msgpack.pack(locals()[name], f)

logging.info('Done.')

